name: mock-build-and-deploy

on:
  workflow_dispatch:
    inputs:
      BUILD_TIME:
        description: build length (in seconds)
        type: string
        required: true
        default: 1
      DEPLOYMENT_TIME:
        description: deployment lengths (in seconds)
        type: string
        required: true
        default: 1
      FAIL_DEPLOYMENT_TO:
        description: if not "none", will have job that deploys to given environment fail
        type: choice
        options:
          - none
          - dev
          - int
          - prod
        required: true
        default: none

jobs:
  build-job:
    uses: cawfeecake/my-reusable-workflows/.github/workflows/sleep.yaml@main
    with:
      TIME_TO_SLEEP: ${{ inputs.BUILD_TIME }}
  determine-if-should-queue:
    runs-on: ubuntu-latest
    outputs:
      should-queue-map: ${{ steps.action.outputs.should-queue-map }}
      previous-run: ${{ steps.action.outputs.previous-run }}
    env:
      RUN_TO_QUEUE: ${{ github.run_number }}
      JOB_NAMES: >-
        deploy-dev
        deploy-int
        deploy-prod
    steps:
      - id: action
        uses: cawfeecake/actions-determine-to-queue@main
        with:
          RUN_TO_QUEUE: ${{ env.RUN_TO_QUEUE }}
          JOB_NAMES: ${{ env.JOB_NAMES }}
  queue-before-deploy-dev-if-needed:
    needs: [ build-job, determine-if-should-queue ]
    if: fromJson(needs.determine-if-should-queue.outputs.should-queue-map)['deploy-dev'] == 'true'
    runs-on: ubuntu-latest
    env:
      PROCEEDING_RUN: ${{ needs.determine-if-should-queue.outputs.previous-run-id }}
    steps:
      - run: |
          echo "Hello world: $PROCEEDING_RUN"
#  determine-if-next:
#    needs: [ build-job ]
#    runs-on: ubuntu-latest
#    steps:
#      - env:
#          GITHUB_TOKEN: ${{ github.token }}
#        run: |
#          previous_run_number=$((${{ github.run_number }} - 1))
#          if [[ $previous_run_number > 0 ]]; then
#            # question: is this the best way to get information on the n - 1 workflow?
#            twenty_most_recent_runs=$(mktemp)
#            # note: default for --limit in following command is 20
#            gh run list -R ${{ github.repository }} -w ${{ github.workflow }} --json conclusion,databaseId,number,status > $twenty_most_recent_runs
#            # <debug>
#            echo '::group::20 most recent workflow runs'
#            jq . $twenty_most_recent_runs
#            echo '::endgroup::'
#            # </debug>
#            previous_run_array=$(jq --argjson prev "$previous_run_number" 'map(select(.number == $prev))' $twenty_most_recent_runs)
#            if [[ $(jq 'length' <<< $previous_run_array) > 0 ]]; then
#              previous_run=$(jq 'first' <<< $previous_run_array)
#              # <debug>
#              echo '::group::previous workflow run'
#              jq . <<< $previous_run
#              echo '::endgroup::'
#              # <debug>
#              while : ; do
#                run_conclusion=$(jq --raw-output '.conclusion' <<< $previous_run)
#                if [[ $run_conclusion == '' ]]; then
#                wait_for_status_array=$('pending', 'waiting',
#                else
#                  break
#                fi
#               # all possible workflow "status" values:
#               #
#               # only when concluded:
#               # - completed
#               # - cancelled
#               # - failure 
#               # - neutral
#               # - skipped
#               # - stale (?)
#               # - success
#               # - timed_out (?)
#               #
#               # only when has not concluded:
#               # - in_progress (happens when a workflow job (steps, too?) is executing)
#               # - queued (happens when workflow (steps, too?) has been notified to start, but has not yet started
#               # - waiting (happens when waiting for protected environment requirements to be satisfied)
#               # - pending (happens when waiting for concurrency group key)
#               #
#               # (?) unknown:
#               # - action_required, only when concluded? does this happen when a job or step cannot call reusable workflow or action?
#               # - requested, only when has not concluded? cron related? (similar case to "queued" status?)
#               #
#
#
#                run_status=$(jq --raw-output '.status' <<< $previous_run)
#                if [[ $run_status == 'pending' ]]; then
#                  _TIMEOUT_SECONDS_BETWEEN_CHECKS=5
#                  while : ; do
#                    sleep $_TIMEOUT_SECONDS_BETWEEN_CHECKS
#
#                    echo 
#                    break
#                  done
#                else
#                  echo "::info::status of previous run (#$previous_run_number) is: \"$run_status\""
#                fi
#              fi
#            else
#              echo "::warning::unable to find the previous run (#$previous_run_number) in most recent 20 workflow runs"
#            fi
#          else
#            echo '::info::this is the first run of the workflow; proceeding...'
#          fi
  deploy-dev:
    needs: [ build-job, queue-before-deploy-dev-if-needed ]
    if: |
      (always() && ! cancelled() && ! failure()) &&
      needs.build-job.result == 'success' &&
      (needs.queue-before-deploy-dev-if-needed.result == 'success' || needs.queue-before-deploy-dev-if-needed.result == 'skipped')
    uses: cawfeecake/my-reusable-workflows/.github/workflows/sleep.yaml@main
    with:
      CONCURRENCY_KEY: dev
      ENVIRONMENT: dev
      TIME_TO_SLEEP: ${{ inputs.DEPLOYMENT_TIME }}
      SHOULD_FAIL: ${{ inputs.FAIL_DEPLOYMENT_TO == 'dev' }}
  queue-before-deploy-int-if-needed:
    needs: [ deploy-dev, determine-if-should-queue ]
    if: fromJson(needs.determine-if-should-queue.outputs.should-queue-map)['deploy-int'] == 'true'
    runs-on: ubuntu-latest
    env:
      PROCEEDING_RUN: ${{ needs.determine-if-should-queue.outputs.previous-run-id }}
    steps:
      - run: |
          echo "Hello world: $PROCEEDING_RUN"
  deploy-int:
    needs: [ deploy-dev, queue-before-deploy-int-if-needed ]
    if: |
      (always() && ! cancelled() && ! failure()) &&
      needs.deploy-dev.result == 'success' &&
      (needs.queue-before-deploy-int-if-needed.result == 'success' || needs.queue-before-deploy-int-if-needed.result == 'skipped')
    uses: cawfeecake/my-reusable-workflows/.github/workflows/sleep.yaml@main
    with:
      CONCURRENCY_KEY: int
      ENVIRONMENT: int
      TIME_TO_SLEEP: ${{ inputs.DEPLOYMENT_TIME }}
      SHOULD_FAIL: ${{ inputs.FAIL_DEPLOYMENT_TO == 'int' }}
  queue-before-deploy-prod-if-needed:
    needs: [ deploy-int, determine-if-should-queue ]
    if: fromJson(needs.determine-if-should-queue.outputs.should-queue-map)['deploy-prod'] == 'true'
    runs-on: ubuntu-latest
    env:
      PROCEEDING_RUN: ${{ needs.determine-if-should-queue.outputs.previous-run-id }}
    steps:
      - run: |
          echo "Hello world: $PROCEEDING_RUN"
  deploy-prod:
    needs: [ deploy-int, queue-before-deploy-prod-if-needed ]
    if: |
      (always() && ! cancelled() && ! failure()) &&
      needs.deploy-int.result == 'success' &&
      (needs.queue-before-deploy-prod-if-needed.result == 'success' || needs.queue-before-deploy-prod-if-needed.result == 'skipped')
    uses: cawfeecake/my-reusable-workflows/.github/workflows/sleep.yaml@main
    with:
      CONCURRENCY_KEY: prod
      ENVIRONMENT: prod
      TIME_TO_SLEEP: ${{ inputs.DEPLOYMENT_TIME }}
      SHOULD_FAIL: ${{ inputs.FAIL_DEPLOYMENT_TO == 'prod' }}
